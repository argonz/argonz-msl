;; MATE STANDARD LIB - SEQUENCE OPERATIONS
(in-ns 'msl)


(defn ranges-distinct [& ns]
  (reverse (second (reduce (fn [[i rs] n] [(+ i n) (cons (range i (+ n i)) rs)])
			   [0 []]
			   ns))))
(defn index 
  ([coll e] (index coll e =))
  ([coll e pred] (loop [[c & cs] coll
			i 0]
		   (if c
		     (if (pred c e)
		       i
		       (recur cs (inc i)))))))
(defn ortolize [seqs]
  (apply #'map #'list seqs))

(defn last-nth [n coll]
  (take-last n coll))
(defn drop-nth [n coll]
  (lazy-seq
    (when-let [s (seq coll)]
      (concat (take (dec n) s) (drop-nth n (drop n s)))))) 
(defn drop-ith [i coll]
  (concat (take i coll) (drop (inc i) coll)))

(defn concat-distinct [& seqs]
  (distinct (apply concat seqs)))

(defn has? [seq e]
  (some #(identical? e %) seq))
(defn member? 
  ([coll e] (member? coll e identical?))
  ([coll e pred] (some (fn [c] (pred c e)) coll)))


;; substitue elements in coll to e if predicate holds
(defn substitute [coll e pred]
  (for [c coll]
    (if (pred c e)
      e
      c)))      
;; substitue if predicate-holds in coll0 to coll1
(defn substitute-coll [coll0 coll1 pred]
  (loop [[c1 & acs1] coll1
	 ncoll0 coll0]			;the replaced coll0
    (if c1
      (recur acs1 (substitute ncoll0 c1 pred))
      ncoll0)))


	    
(defn find-first [pred coll]
  (loop [c coll]
    (if (seq c)
      (if (pred (first c))
	(first c)
	(recur (rest c))))))
(defn pick [pred coll]			;= find-first
  (loop [c coll]
    (if (seq c)
      (if (pred (first c))
	(first c)
	(recur (rest c))))))
(defn remove-first [pred coll]
  (loop [bc []
	 ac coll]
    (if (seq ac)
      (if (pred (first ac))
	(concat bc (rest ac))
	(recur (conj bc (first ac)) (rest ac)))
      coll)))
 
(defn remove-element 
  ([e coll pred] (remove (fn [i] (pred e i)) coll))
  ([e coll] (remove-element e coll identical?)))
(defn remove-elements
  ([es coll pred] (remove (fn [i] (some (fn [j] (pred i j)) es)) coll))
  ([es coll] (remove-elements es coll identical?)))

     
     


(defn pos [coll element]
  (loop [cs coll 
	 i 0]
    (if (empty? cs)
      nil
      (if (= (first cs) element)
	i
	(recur (rest cs) (+ i 1))))))

(defn tupelize 
  ([coll] (tupelize coll 2))
  ([coll n] (reverse (loop [c coll r (list)]
		       (if (empty? c)
			 r
			 (recur (nthnext c n) (conj r (take n c))))))))

(defn take-indexes [coll indexes]
  (map (fn [i] (nth coll i)) indexes))


(defn replace-index [coll index replace]
  (concat (take index coll) [replace] (drop (inc index) coll)))
(defn replace-indexes [coll indexes replaces]
  (reduce (fn [c i r] (replace-index c i r)) coll indexes replaces))
(defn replace-nth [coll n e]
  (concat (take n coll) [e] (drop (inc n) coll)))
(defn replace-nths [coll ns es] 
  (reduce (fn [c n r] (replace-nth c n r)) coll ns es))

;; add element to the subcollections based on the predicate
(defn insert-group [pred groups e]
  (loop [bgs []
	 [g & ags] groups]
    (if g
      (if (pred e (first g))
	(concat bgs [(conj g e)] ags)
	(recur (conj bgs g) ags))
      (conj bgs [e]))))

;; form subcollections based on the predicate
(defn group [pred coll]
  (loop [[c & acs] coll
	 gs []]
    (if c
      (recur acs (insert-group pred gs c))
      gs)))
(defn sort-groups 
  ([comp gs] (sort (fn [[g0 & _] [g1 & _]] (comp g0 g1))
		   (map (fn [g] (sort comp g)) 
			gs)))
  ([gs] (sort-groups < gs)))
      
;; 
(defn lref [seq & refs]
  (loop [s seq
	 rs refs] 
    (if (empty? rs)
      s
      (recur (nth s (first rs)) (rest rs)))))
      
(defn seq-translate [item seq0 seq1]
  (loop [s0 seq0
	 s1 seq1]
    (if (= (first s0) item)
      (first s1)
      (recur (rest s0) (rest s1)))))


;; (defn list-to-vec [list]
;;   (if (list? list)
;;     (

;; (defn deep-apply-on-col [f coll]
;;   (if (coll? coll)
;;     (doseq [c coll] (deep-apply-on-col f c))
;;     (apply f coll)))


;; ugly as hell -> 1d vector for tensors 
;; definetely should be a java class :)
;; (ns tensor 
;;   (:refer-clojure))
;; (defn init [dims]
;;   {:dims dims
;;    :vec (vector (range )})
;; (defn aref [tensor & indexes]
;;   (nth (:vec tensor) (reduce + (map * 
